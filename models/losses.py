from typing import List

import torch
from torch import Tensor
import torch.nn as nn

from .buildingblocks import Vgg19FeatExtrator 

class AdvLoss(nn.Module):
    """ Adversarial Loss function.
    
    This loss function tell us how close the generated data is of being
    taken as a real data by the discriminator."""
    def __init__(self) -> None:
        """ Constructs a new adversarial loss function. """
        super(AdvLoss, self).__init__()
        self.criterion = nn.MSELoss()
        self.register_buffer('real_label', torch.tensor(1.0))

    def forward(self, x: Tensor) -> Tensor:
        """ The default forward.

        Calculates how close the generated data is of being
        taken as a real data by the discriminator

        Parameters:
            x (Tensor) -- data generated by the generator network
        Return (Tensor) -- tensor of float numbers
        """
        real_label = self.real_label.expand_as(x)
        return self.criterion(x, real_label)

class DiscLoss(nn.Module):
    """ The loss function that the discriminator network should minimizes.
    
    This loss function tells us how good the discriminator is in detecting
    real and fake (generated) data.
    """
    def __init__(self) -> None:
        """ Constructs a new loss function to the discriminator."""
        super(DiscLoss, self).__init__()
        self.criterion = nn.MSELoss()
        self.register_buffer('real_label', torch.tensor(1.0))
        self.register_buffer('fake_label', torch.tensor(0.0))

    def forward(self, x: Tensor, y: Tensor) -> Tensor:
        """ The default forward.

        Calculates how good the discriminator is in detecting
        real and fake (generated) data.

        Parameters:
            x (Tensor) -- prediction given by the discriminator for a real data
            y (Tensor) -- prediction given by the discriminator for a fake (generated) data
        Return (Tensor) -- tensor of float numbers
        """
        real_label = self.real_label.expand_as(x)
        fake_label = self.fake_label.expand_as(y)
        return self.criterion(x, real_label) + self.criterion(y, fake_label)
        
class FMLoss(nn.Module):
    """ Feature Matching Loss.

    This loss function forces the model to match the intermediate 
    features of the generated data with the respective intermediate
    features of the real data.
    """
    def __init__(self) -> None:
        """ Constructs a new Feature Matching loss function """
        super(FMLoss, self).__init__()
        self.criterion = nn.L1Loss()
        
    def forward(self, x: Tensor, y: Tensor) -> Tensor:
        """  Calculates the feature matching loss
        Parameters:
            x (List[Tensor]) -- intermediate features and output of the 
                                discriminator for the real data
            y (List[Tensor]) -- intermediate features and output of the 
                                discriminator for the generated data

        Return (Tensor) -- the feature matching loss"""
        num_of_layer = len(x)
        weights = [1.0 / float(2**(num_of_layer - i)) \
                        for i in range(1, num_of_layer + 1)]
        loss = 0
        for i in range(len(x)):
            loss += weights[i] * self.criterion(x[i], y[i])
        return loss

class PerceptualLoss(nn.Module):
    """ Perceptual loss aplied to the generator network.
    
    This type of loss function is by itself a deep neural network.
    In this case, we are using Vgg19 as our loss network.
    """
    def __init__(self, return_layers: List[int]) -> None:
        """ Constructs a new perceptual loss 
        Parameters:
            return_layers (List[int]) -- list where each item is the index
                                         of the layer one want to extract from 
                                         the vgg19
        """
        super(PerceptualLoss, self).__init__()
        return_layers = {str(i) : 'layer' + str(i) for i in return_layers}
        self.model = Vgg19FeatExtrator(return_layers)
        self.criterion = nn.L1Loss()
        
        num_of_layer = len(return_layers)
        self.weights = [1.0 / float(2**(num_of_layer - i)) \
                        for i in range(1, num_of_layer + 1)]

    def forward(self, x: Tensor, y: Tensor) -> Tensor:
        """ Calculates the Perceptual loss between the x and y tensors.
        Parameters:
            x (Tensor) -- output from the generator network
            y (Tensor) -- ground-truth tensor
        Return (Tensor) -- The mean of the L1 norm between x and y
                           weighted by the itens in the weights list
        """
        loss = 0
        vgg_x = self.model(x)
        vgg_y = self.model(y)
        for i in range(len(vgg_x)):
            loss += self.weights[i] * self.criterion(vgg_x[i], vgg_y[i])
        return loss
